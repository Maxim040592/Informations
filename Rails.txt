***Работа с приложением в Rails***
 ***После создания нового приложения необходимо создать контроллер и модель приложения
   - rails generate( либо просто g) controller arcticles ( вместо articles может быть что угодно )
   	Далее нужно перейти в контроллер и прописать 
   	def new 
   	end
   	
   - rails generate( либо просто g) home index (index - это action т.е страница отображения которую нужно создать в кталоге view под именем index.html.erb и уже в ней будет содержаться представление страницы
   
   - rails generate( либо просто g) home (создастся контроллер home в данном случае без action index значит по умолчанию нужно будет создать action в контроллере в зависимости от того какой прописан маршурут в файле ниже routes.rb (resource или resources) - см. рисунок !маршруты Rails! в данном репозитории)
   
   - rails g model Article title :string text :text  ( и сразу перечисляются поля таблицы т.е создасться модель и миграция)
   	Далее необходимо запустить миграцию rake db:migrate
   
  ***Правка файла routes.rb
   - для того чтобы сделать начальную страницу созданным action - index необходимо написать
   	get '/' => 'home#index' - статичная страница т.к для контроллера home указана только страница index (см. создание статичных страниц)
   - для опредления маршрута по url articles/new ( относится к созданному контроллеру articles) необходимо прописать
   	resources :articles
      resource :contacts, only: [:new, :create], path_names: { :new => ''}  # маршруты только на отображение и отрпавку (т.е new отображение, create отправка)
  
 ***Создание статичных страниц
   1 создается контроллер
   2 внутри прописываются нужные страницы (например def about end; def contact end )
   3 в файле routes.rb прописываем (get 'terms' => 'controller_name#about' 
                                    get 'about' => 'controller_name#contact' )
   4 создаем представления для каждой стр
 
 ***Каталог controllers
  ***Структура файла контроллера - на случай всех маршрутов (структура маршрутов можно посмотреть в файле картинки маршруты Rails в данном репозитории)
      class ArticlesController < ApplicationController
        def index #отображение списка
        end
        
        def show #показ страницы
        end
        
        def new #создание страницы (GET запрос)
        end
        
        def create #отправка страницы (POST запрос)
        end

        def edit #редактирование страницы (GET запрос)
        end

        def update #редактирование страницы (PUT/PATCH запрос)
        end
        
        def destroy #удаление страницы (PUT/PATCH запрос)
        end

        private
        #разрешение на передачу параметров
        def article_params
          params.require(:article).permit(:title, :text)
        end
      end
  
   ***Команды sqlite3
      - .tables - список таблиц
      - .mode column - формирует колоник (отступы)
      - .headers on - включает заголовки
      - pragma table_info(table_name) - отображает поля и их типы
  
  ***Команды Rails
      - render action: 'edit' - перенаправит на страницу edit без потери значения переменой (если такая есть в данном action)
      - redirect_to @article - перенаправление по нужному пути в REST, где @article это @article = Article.new(article_params) т.е сущность полученнная с переданными параметрами из мтода article_params описанный в private
      - @article.save - сохранение в БД
      - @article.update(article_params) - обновление в БД по переданым параметрам из private метода article_params
      - <%= link_to 'Show_article', article_path(article)%> 
            #создаст ссылку 'Show_article' с переходом на страницу arcticles(статьи) по ее id. 
            #где article это <% @articles.each do |article|%> т.е элемент массива
            # @articles - переменная содержащая массив Модели Article т.е  @articles = Article.all (код из action index)
      - <%= link_to 'Edit_article', edit_article_path(article)%>
            #создаст ссылку 'Edit_article' с переходом на страницу arcticles(статьи)/id/edit по ее id. 
            #где article это <% @articles.each do |article|%> т.е элемент массива
            # @articles - переменная содержащая массив Модели Article т.е  @articles = Article.all (код из action index)
      -  <%= link_to 'Destroy_article', article_path(article), method: :delete, data: {confirm: 'Действительно хотите удалить данную статью?' }%>
            # создает ссылку на удаление. В данной ссылке сразу прописывается метод delete (данный метод формирует rails т.к барузеры знают только GET и POST
            # data: {confirm: 'Действительно хотите удалить данную статью?' } - выдает диалоговое окно с подтверждением или отменой удаления
      - rails g model Comment author:string body:text article:references - создание модели в режиме создания отношения свзи(т.е 1 ко многим 1 к 1 и т.д)
            # article:references - создание поля отношений связи с таблицей article
            
 ***Каталог views(представления - .html.erb)
 ***предстваление edit.html.erb
      <%= form_for :article, url: article_path(@article), method: :put do |f| %> 
      #т.е article_path - переменная маршрута контроллера(т.е /edit) 
      #@article - глобальная переменная которая прописана в action edit т.е @article = Article.find(params[:id])
      #method: :put - грубо говоря хэш где method: - ключ :put - значение. Данный метод создается раилсом для страницы /update (см. рис  "маршруты Rails" в данном репозитории)
      #т.е браузер не знает такой метод "PUT" поэтому Rails его создает путем создания скрытого поля с нужными параметрами 
         <p>
          <%= f.label :title %> <br> #f.label формирует в браузере тег <label>
          <%= f.text_field :title %> #f.label формирует в браузере тег <input>
        </p>
         <p>
          <%= f.submit %>
        </p>
      <% end %>
      
 ***Принужительный метод для использования конкретного маршрута
    - Например маршрут /user/sign_out использует метод DELETE но браузер не знает метод. заменяем его при помощи RAils командой data-method="delete"
      <a href="/users/sign_in">Войти</a>|<a href="/users/sign_out" data-method="delete">Выйти</a>
  
  ***Console Rails
     Запускается командой rails console
     Команды:
      - *имя модели*.attribute_names - покажет все поля в табл
      - *имя модели*.count - количество значений в табл
   
 ***Gem аторизации в Rails
      - gem install devise
      or
      - в файле Gemfile (gem devise) затем в консоли bundle
    * Запуск
      - rails g device:install (потребуется настройка которая будет в описана в консоли)
      и затем создается модель авторизации
      - rails g devise User
    * Блокировка страницы путем авторизации
      - В контроллере в самом вверху прописываем  - before_action :authenticate_user!
    * Проверить факт входа пользователя в систему можно с помощью следующего хэлпера:
       - user_signed_in?
    * С помощью следующего хэлпера мы получим объект пользователя, авторизованного в данный момент на сайте
       - current_user
    * Вывести электронную почту пользователя можно следующим образом
       - current_user.email
    * Доступ к текущей сессии можно получить так:
       - user_session
